const classed = require('@compone/class')
    , event = require('@compone/event')
    , client = require('utilise/client')
    , id = { count: 0 }
    , noop = () => {}
    , HTMLElement = client ? window.HTMLElement : class {}

module.exports = function define(name, component) {
  if (arguments.length == 1) { component = name, name = `anon-${id.count++}` }
  if (!name.includes('-')) return;
  if (!client) return wrap(component)
  let wrapped = customElements.get(name)

  if (wrapped) {
    const instances = Array.from(document.querySelectorAll(name))
    instances.map(node => {
      node.disconnectedCallback()
      node.methods.map(method => { delete node[method] })
    })
    wrapped[classed.symbol] = classed(component)
    instances.map(node => node.connectedCallback())
  } else {
    customElements.define(name, wrapped = wrap(component))
  }

  return wrapped
}


const wrap = component => {
  const wrapper = class extends HTMLElement {
      async connectedCallback(){ 
        const { prototype } = wrapper[classed.symbol]
        event(this)
        this.state = this.state || {}
        this.methods = Object
          .getOwnPropertyNames(prototype)
          .filter(method => !(method in disallowed))
          .map(method => ((this[method] = prototype[method].bind(this)), method))

        await (this.connected || noop).call(this, this, this.state)
        this.initialised = true
        this.render()
      }

      async render(){
        const { prototype } = wrapper[classed.symbol]
        if (!this.initialised) return
        await prototype.render.call(this, this, this.state) 
      }

      disconnectedCallback(){
        (this.disconnected || noop).call(this, this, this.state)
        this.dispatchEvent(new CustomEvent('disconnected')) 
        this.initialised = false
      }
    }

    wrapper[classed.symbol] = classed(component)
    return wrapper
}

const disallowed = { length: 1, prototype: 1, name: 1, render: 1 }